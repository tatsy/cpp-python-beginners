---
layout: post
title: "k-d木による最近傍探索"
---

点群からメッシュを復元する場合には、入力頂点を法線方向にオフセットすることで、その点での参照値が$\{ -1, 1 \}$となるような点を追加すると述べた。

しかしながら、例えば、以下の論文の図3(a)などのように、曲面が近い距離で向かい合っているような場合には、頂点を一定距離でオフセットした際に、それが曲面が囲む領域の内側に入り込んでしまう可能性がある。

* Carr et al. 2001, "Reconstruction and Representation of 3D Objects with Radial Basis Functions"

このような場合に、整合しない陰関数の参照値を与えてしまうことを防ぐため、頂点を法線方向にオフセットしたあと、入力の点群の中から、最もオフセット後の点のいちに近い頂点を探索してきて、その頂点の位置と法線の方向から実際の参照値$d_i$を計算する。

ここで重要となるのは、数万点程度の入力点群の中から、どのように最近傍となる頂点を効率的に探し出すか、ということである。このような効率的な近傍点の探索には、木構造をはじめとするデータ構造がよく用いられる。今回は、このようなデータ構造の中からk-d木を紹介する。

## k-d木の構築

k-d木は任意の次元$k$を持つ空間 ($k$-dimensionalでk-d)を分割する木構造である。k-d木は一つのノードが2つの子を持つような二分木の一種であり、一つひとつのノードはk次元空間の特定の領域に含まれる点 (あるいは別のデータ)の情報を管理する。k-d木の中では親子関係のない各ノードが支配する領域が重複することはない (親ノードは子ノードの領域を支配している)。

入力されたデータが点群である場合には、k-d木はトップダウンに作成される。ルートとなるノードがすべての頂点を支配している状態からスタートして、ノードを、X, Y, Z軸方向のなかで、そのノードが含む頂点の位置の分散が最大となる方向に垂直な平面で分割していく。

分割位置については、頂点を分散最大方向の変位によりソートして、その要素が半分ずつに分かれるように決定する。また、分割面は少なくとも1つの頂点を通るように選んでおき、各ノードには分割面上の情報も記録しておく。この分割をノードが支配する頂点の数が1つになるまで繰り返すことでk-d木が構築される。

## k-d木を用いた最近傍探索

k-d木を用いると、クエリとなる頂点と最も近い頂点を効率的に探索することができる。これは、仮にクエリ頂点と今の探索しているノードとの分割面までの距離が、今見つかっている点の中で最も近いへの距離よりも遠ければ、反対側の兄弟ノードを探索する必要がなくなるためである。

今、上記の構築方法から分割面上には少なくとも1つの頂点が含まれることが分かっているので、木を下に探索していくごとに、調べなければならない範囲は急速に小さくなっていく。そのため、最近傍点の探索にかかる計算コストは入力頂点の数を$N$として、わずか$O(\log N)$となる。

また、この方法を拡張すると、クエリ点からみて一定の半径内に入っている点だけを取り出したり、クエリ点から近い順に決まった数の点を取り出したりすることができる。

## テンプレート・プログラム内での実装について

k-d木の実装はなれていないとやや難しい部分もあるため、今回は最近傍点の探索と、一定の半径内に含まれる点の探索を行う関数を備えた実装をそのまま提供している。

このk-d木の実装はテンプレート・クラス (テンプレート・プログラムと言葉がややこしいが、ここでのテンプレートはC++における用語)となっていて、`KDTree<Vec3>`のように入力の点を表す変数の型を与えて用いる。

テンプレート・クラス (およびテンプレート関数)は、異なる型に対して、共通の機能を実装することができ、さらにテンプレート引数に与えられた型が利用条件を満たさないときにはコンパイルエラーとすることができます。

今回の実装においては、k-d木の入力点群を表す型が、`T::x, T::y, T::z` のように三次元座標の各要素を返し、さらに2つの点をとって、その間の距離を返す関数`length(const T&, const T&)`が定義されていることを仮定しています。

テンプレート・プログラムで与えている`Vec3`型はどちらの条件も満たすため、そのまま`KDTree<Vec3>`のようにして使うことが可能です。また、頂点の番号などの追加情報をもたせたいときには、`Vec3`型を継承して、新しい型を定義するのが良いだろう。

クラスの継承は、初心者には難しい部分もあるので、テンプレート・プログラム内に`Vec3`型を継承して頂点番号を加えた`Point`型を定義しておいた (`surface_recon.cpp`内)ので参考にしてほしい。

ちなみに、テンプレート関数ならびにテンプレート・クラスはとても便利な機能ではあるが、一般的にコンパイルエラーのメッセージが分かりづらくなり、また必ずヘッダファイルに定義を書かないといけないためにコンパイルにかかる時間が増える傾向にある。

意見が分かれるところではあると思うが、テンプレートを使うのは、テンプレートを使わなければ実現できないような実装をする場面 (可変長テンプレートなどを使う時)や、ベクトル型などの基本的な型を定義する場合に限定しておきたい (ちなみに後者の場合はマクロを使うことでテンプレートを使わない実装も可能、こちらはコンパイルは速いが、デバッグはより難しくなる)。
